# 병합 정렬(Merge Sort)

> 큰 크기의 데이터에 적합한
> <br/>
> 분할정복을 기반으로 하는 빠른 알고리즘

<br/>
<br/>

1. 배열 전체에 `mergeSort` 를 적용한다
2. `mergeSort` 는
    1. middle index 를 기준으로 왼쪽배열과 오른쪽배열로 분할한다.(Divide)
    2. 분할된 2개의 배열에 각각 `mergeSort`를 적용한다.(Solve)
    3. 정렬된 2개의 부분배열을 `merge` 하여 결합한다.(Conquer)

## ⏳ 정렬 과정

정렬할 데이터를 준비 한다.

```
[3,5,1,4,6,2]
```

### 1. `mergeSort` Step
middle index 를 기준으로 왼쪽배열과 오른쪽배열로 분할한다.

```swift
left = [3,5,1]
right = [4,6,2]
```

분할된 왼쪽, 오른쪽 배열에 각각 `mergeSort` 를 적용(재귀)하여, **가장 작은 집합으로 분할**한다.

```swift
/// left Array
    [3,5,1]         // 1
[3]       [5,1]     // 2
         [5] [1]    // 3
```

가장 작은 집합에 `merge` 를 적용하여, **정렬된 집합**으로 결합해 나간다.

```swift
[5]    [1]
   [1,5]
```

### 2. `merge` Step

**준비:** left 집합 / right 집합 / 결과를 담을 배열 

- 이때, left 와 right 는 정렬된 요소들의 집합이다

```swift
 left    right      result
[1,3,5 / 2,4,6]  [0,0,0,0,0,0]
```

1. left 의 첫번째 요소 `1`, right 의 첫번째 요소 `2` 를 비교해 더 작은요소를 결과배열에 넣는다.

```swift
0          3
[1,3,5]   [2,4,6]

RESULT [1]
```

2. left 집합의 요소를 결과배열에 넣었으므로, left index 를 `+1` 

```swift
1          3
[**1**,3,5]   [2,4,6]

RESULT [1]
```

3. 다음, left[1] 과 right[3] 을 비교한다. 
left `3`, right `2` 중에 `2`가 더 작으므로 결과배열에 넣는다

```swift
1          3
[**1**,3,5]   [2,4,6]

RESULT [1,2]
```
4. right 의 index 를 `+1` 

```swift
1          4
[**1**,3,5]   [**2**,4,6]

RESULT [1,2]
```

5. left[1] `3`, right[4] `4` 중에 더 작은값인 left[1] 를 결과배열에 넣는다. left index + 1

```swift
1+1          4
[**1**,**3**,5]   [**2**,4,6]

RESULT [1,2,3]
```

6. left[2] `5`, right[4] `4` 중에 더 작은값인 right[4] 를 결과배열에 넣는다. right index + 1

```swift
2          4+1
[**1**,**3**,5]   [**2**,4,6]

RESULT [1,2,3,4]
```

7. left[2] `5`, right[5] `6` 중에 더 작은값인 left[2] 를 결과배열에 넣는다. left index + 1

```swift
2          5
[**1**,**3**,**5**]   [**2**,**4**,6]

RESULT [1,2,3,4,5]
```

8. 두 집합의 비교 정렬 후, 뒷처리
- 남은 값을 결과배열에 모두 넣는다.
- left 가 남았다면 먼저 넣고, 그다음에 right 요소들을 넣는다.
- middle index = `3` (6/2)
- left 판단: index가 middle index -1 보다 작은가 ⇒ left 요소가 남았다
- right 판단: index가 배열의 끝(6) 보다 작은가 ⇒ right 요소가 남았다

```swift
2          5(요소가 남음)
[**1**,**3**,**5**]   [**2**,**4**,6]

RESULT [1,2,3,4,5,6]
```

<br/>
<br/>

## 🕰 시간 복잡도

- $`O(NlogN)`$
    
    ```
    너비(데이터의 갯수) * 높이 = N * logN = NlogN
    ```
    
    - 높이는 연산할때마다 $2^1$ → $2^2$ → $2^3$ 씩 증가 ⇒ 작은 단계만 수행해도 전체 데이터를 확인
    - 높이는 데이터의 범위가 절반씩 줄어들기 때문에 $logN$ 이다
    - 
- 두가지 배열을 비교해 합치는 `merge` 는 $O(N)$
    - 이미 정렬된 집합을 정렬하는 것이기 때문
    - 데이터 갯수 N 개만큼 비교

<br/>
<br/>

## 🖍 결론

- $O(N^2)$ 시간복잡도인 버블정렬과 달리, $O(NlogN)$ 을 보장한다.
- 평균적으로 퀵정렬보다 빠르진 않지만, 언제나 $O(NlogN)$ 을 보장하는 점이 최대 장점
- 빠르고 안정적이지만, 입력 데이터를 저장하고 있는 배열 이외에 일시적으로 메모리 영역이 더 필요하다.

<br/>
<br/>

---

## 참고 자료

- [정렬 알고리즘-동빈나](https://youtu.be/KGyK-pNvWos)
- `책` 알고리즘과 자료구조 입문-프로그래밍 인사이트
